General commands:
>>  select version();
>>  \l                      // show list of databases (backshash L)
>>  \c [databaseName]       // switch(connect) to a new database
>>  \d                      // show the list of tables in a database
>>  create table [test_table](name varchar(50));  // create a new table with name test_table
>>  \dn                     // show the schema in a table
>>  \d+                     // show owner, size, access method,schema
>>  \conninfo               // show the connection info like databaseName, userName, host, port
>>  \q                      // quite the psql shell or terminal


// user access controll of the pSQL database: 
>>  psql -U userName -d your_database_name                                  // login with user to a targeted database
>>  \du                                                                     // show list of user role for database 
>>  create user [userName] with login encrypted password ['123456'];        // create a new user who can manage database, initally this user will have no permission, so give permission to it.
>>  create role [roleName] with login encrypted password ['123456'];        // create a role to give controll database
>>  grant all privileges on table [tableName] to [userName]                 // give permission of a table to a user. 'all privileges' means full CRUD 
>>  grant [select] on table [tableName] to [userName]                       // give Read or select permission to the user
>>  revoke [select] on table [tableName] from [userName]                    // remove Read or select permission from the user



SQL commands classification: 
    - DDl: create, drop, alter, truncate, rename        // (DDL=data definition lang)can create or remove table or database
    - DML: insert, update, delete                       // (DML=data management lang)can modify data from tables or database
    - DCL: grant, revoke                                // (DCL=data control lang)can control user access of tables or database
    - TCL: start transaction, commit, rollback, savepoint                  // (TCL=transection control lang)can control transection during data modification
    - DQL: select                                       // (DQL=data query lang)can query data from tables


Data type
    - boolean: true, false, null
    - number: 
        - int: 4 bytes range(+-2,147,483,648)
        - bigint: 8 bytes range(+-9,223,372,036,854,775,808)
        - smallint: 2 bytes range(+-32,768)
        - float4: 4 bytes & 6 digit precision
        - float8: 8 bytes & 15 digit precision
        - numeric: variable bytes(depend on input precision) bytes range(unlimited precision), ex: Numeric(4,3)
        - serial: range(like integer), auto increment
    - character: 
        - char: fixed length and storage is given during create column, if string is small than the column space, then it is padded with space and take full of the column. ex: CHAR(10) means a fixed-length string with a fixed length 10
        - varchar: variable length character type. Length is not specified and can vary up to the specified maximum length. no padding is added. MOre storage efficient when dealing with variable length string. ex: VARCHAR(255) means a variable length string with a maximum length 255 
        - text: a variable length type similar to VHARCHAR. It is not fixed-length. Typically used for longer text strings where the exact length is not known or can vary widely. Contain large amount og text like blogpost.
    - timestamptz: TIMESTAMPTZ(TIMESTAMP WITH TIME ZONE)
    - binary
    - json
    - uuid
    - array
    - xml

// Initial commands:
********************************DATABASE CRUD**********************************
>>  \l                                                      // check list of available database
>>  CREATE DATABASE [databaseName]                          // create a new database
>>  ALTER DATABASE [dbOldName] RENAME TO [dbNewName]        // change database name
>>  DROP DATABASE [databaseName]                            // delete a database

********************************TABLE CRUD**********************************
>>  CREATE TABLE [tableName](
        column1 datatype constraint,
        column2 datatype constraint,
        column3 datatype constraint,
        ........................
    );                                  // create a new table
                    CREATE TABLE person(
                        id SERIAL,
                        person_id SERIAL,
                        first_name VARCHAR(50) NOT NULL,
                        last_name VARCHAR(50) UNIQUE,
                        customer_id INTEGER REFERENCE customers(customerId),
                        status BOOLEAN DEFAULT true. 
                        age INTEGER CHECK (age >= 18),
                        isActive BOOLEAN,
                        dob DATE
                        PRIMARY KEY(id),
                        FOREIGN KEY (customer_id) REFERENCES customers(customerId),
                        CONSTRAINT age_check CHECK(age >= 18 AND status=true)
                    );
                    Constraints:
                        - NOT NULL: must have a value
                        - UNIQUE:  can't be duplicate
                        - REFERENCES foreignTableName(foreignColumnName)
                        - DEFAULT: set the default value
                        - CHECK: add a if condition to test the custom condition


Table related Queries:
    - ALTER: to change schema or column
    - ADD(add a new column):
        >> ALTER TABLE table_name 
            ADD COLUMN column_name datatype constraints;

    - DROP (drop an old column):
        >> ALTER TABLE table_name 
            DROP COLUMN column_name;

    - RENAME TO (change table name):
        >> ALTER TABLE table_name 
            RENAME TO new_table_name;

    - RENAME COLUMN(change column name):
        >> ALTER TABLE table_name 
            RENAME COLUMN old_column_name TO new_column_name;
    
    - SET/DROP(change datatype/constraint):
        >> ALTER TABLE table_name                                           // table name
            ALTER COLUMN column_name SET DATA TYPE data_type,               // data type
            ALTER COLUMN column_name SET DEFAULT default_value NOT NULL,    // constraints                    
            ALTER COLUMN column_name SET NOT NULL,                            
            ALTER COLUMN column_name DROP NOT NULL;                            
    - TRUNCATE(delete all rows or empty the table but keep the columns & constraints)
        >> TRUNCATE TABLE table_name;         

    - ADD CONSTRAINT(add constraint on a column): give a name of constraint = `constraint_name+table_name+column_name`
        >> ALTER TABLE table_name
            ADD CONSTRAINT constraint_name_table_name_col_name CONSTRAINT_NAME(col_name);
            eg: ALTER TABLE users
                ADD CONSTRAINT unique_users_age UNIQUE(age);
                ADD CONSTRAINT pk_users_age PRIMARY KEY(age);
    

>> DROP TABLE [tableName]                                   // delete or remove a table from database
>> INSERT INTO tableName (column1, column2, column3) 
                VALUES(value1_1,value1_2,value1_3),
                VALUES(value2_1,value2_2,value2_3),
                VALUES(value3_1,value3_2,value3_3),


SELECT: Retrive data from tables
    - SELECT
    - DISTINCT  : DISTINCT ensure only unique rows are returned, no duplicate
    - FROM 
    - WHERE 
    - ORDER 
    - GROUP BY  : group rows that have the same value in specified cols
    - HAVING    : Filters the result of a GROUP BY clause based on specified condition (usually aggregated functions)
    - JOIN 
    - LIMIT     : sort the data
    - OFFSET    : number of rows to skip before starting to return rows.

                        
    >> SELECT DISTINCT col1 as "customName",
        UPPER(col2),
        AVG(col3), 
        CONCAT(fname,' ',lname) AS full_name, 
        CASE 
            WHEN age >= 18 
                THEN 'Adult' 
            ELSE 'Minor' 
        END AS "Age Category",
        COALESCE(email,"email not given") as "Email"                              
        FROM TABLE table1
        JOIN table2 ON table1.column3 = table2.column5
        WHERE condition1 AND condition2
        GROUP BY column1                                        
        HAVING aggregate_function(column2) > value               
        ORDER BY column1 DESC                                   
        LIMIT 10
        OFFSET 5;                                               

SELECT Functions: Operate on a set of rows and return a single value summarizing on the set. Often used with the GROUP BY clouse.
    ~ Aggregate Functions:
        - COUNT()
        - MAX()
        - MIN()
        - SUM()
        - AVG()
        >> SELECT age, AVG(marks)
            FROM student
            GROUP BY age
            HAVING MAX(age) > 15
            ORDER BY AVG(age), id DESC
            LIMIT 4;

    ~ Scalar Functions: Operate on each single row and return single value for each row.
        - UPPER(text)
        - LOWER(text)
        - CONCAT(text1,text2,...)
        - INITCAP(text)                 : Capitalizes the first letter of each word in a string.
        - LENGTH(text)
        - SUBSTRING(text FROM startLengthNumber FOR characterlengthNumber)
        - TRIM(text)
        - REPLACE(text, from_substring, to_substring) : replace a part of text. eg. REPLACE('hello world', 'world', 'universe'); returns 'hello universe'.
        - POSITION(substring IN string) : Returns the position of a substring within a string. eg. POSITION('l' IN 'hello'); returns 3.
        - COALESCE(value1, value2, ...) : Returns the first non-null value in the list. When we want not to send any null value, then use this method. It will return the next value if first value being NULL. eg.  COALESCE(NULL, 'hello', 'world'); returns 'hello'.
        - ROUND(number [, precision])   : Rounds a number to a specified number of decimal places. eg. ROUND(3.14159, 2)  returns 3.14
        - CAST(expression AS type): Converts a value to a specified data type. eg, CAST('123' AS INTEGER) returns 123.

IS vs Equal(=):
    ~ IS:
        - typically use IS NULL or IS NOT NULL to check whether a column or expression contains a NULL value.
        - When you want to check for NULL values explicitly.
        - For comparisons involving NULL values.
    ~ Equal(=):
        - The = operator is used for equality comparison between two values or expressions.
        - When you want to compare non-NULL values for equality.
        - For regular value comparisons.


Operators:
    - IN        : checks whether a value matches any value in a list.
                    >> SELECT * FROM employees WHERE department_id IN (101, 102, 103);
    - BETWEEN   : checks whether a value lies within a specified range.
                    >> SELECT * FROM products WHERE price BETWEEN 10 AND 100;
    - LIKE      : Search for a specified pattern in a column. % is used as a wildcard to match any sequence of characters, and _ matches any single character.
                    >> SELECT * FROM customers WHERE last_name LIKE 'Sm%';   // It match the last_name start with 'Sm....'.
                    >> SELECT * FROM customers WHERE last_name LIKE '%Sm';   // It match the last_name ends with '...Sm'.
                    >> SELECT * FROM customers WHERE last_name LIKE '__sm%';   // It match the last_name first 2 characters can be anything, 3rd & 4th character will be 'sm' then ends can be any other characters. Here the double underscore '__' represent each character index. 
    - ILIKE     : performs a case-insensitive pattern match.
                    >> SELECT * FROM products WHERE product_name ILIKE '%apple%';



Delete Operations:
    -  delete based on condition 
        >> DELETE FROM table_name 
            WHERE condition
            eg: DELETE FROM student where marks < 33;

Update OPeration:
    >> UPDATE table_name
        SET col1=val1, col2=val2
        WHERE condition;
        eg: UPDATE student SET marks=78 WHERE id=14;